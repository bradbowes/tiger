use "sources.tig"
use "symbols.tig"

and_token = 1
array_token = 2
assign_token = 3
begin_token = 4
char_token = 5
colon_token = 6
comma_token = 7
comment_token = 8
div_token = 9
do_token = 10
dot_token = 11
else_token = 12
end_token = 13
eof_token = 14
eq_token = 15
false_token = 16
for_token = 17
geq_token = 18
gt_token = 19
id_token = 20
if_token = 21
in_token = 22
lbrace_token = 23
lbracket_token = 24
leq_token = 25
let_token = 26
lparen_token = 27
lt_token = 28
minus_token = 29
mod_token = 30
mul_token = 31
neq_token = 32
nil_token = 33
number_token = 34
of_token = 35
or_token = 36
plus_token = 37
rbrace_token = 38
rbracket_token = 39
rparen_token = 40
semicolon_token = 41
string_token = 42
then_token = 43
to_token = 44
true_token = 45
type_token = 46
use_token = 47
while_token = 48

type token = {
   tag: int,
   value: string,
   file_name: string,
   line: int,
   col: int
}

tok = token { tag = 0, value = "", file_name = "", line = 0, col = 0 }
buf = make_buffer(4096)

push_buf() =
   begin
      push_buffer(buf, ch)
      nextch()
   end

tok_location(): location =
   location {
      file_name = tok.file_name,
      line = tok.line,
      col = tok.col
   }

skip_spaces() =
   while is_space(ch) do
      nextch();

recognize(tag: int) =
   begin
      tok.tag := tag
      tok.value := get_buffer(buf)
   end

push_tag(tag: int) =
   begin
      push_buf()
      recognize(tag)
   end

scan_comment() =
   begin
      push_buf()
      while buf.ptr < 4 or ch <> #"/" do
         begin
            while ch <> #"*" do
               push_buf()
            while ch = #"*" do
               push_buf()
         end
      push_buf()
      recognize(comment_token)
   end

scan_string() =
   let
      escape = chr(0)
      code = 0
   in
      nextch()
      while ch <> #"\"" do
         if ch = #"\\" then
            let
               esc = true
            in
               nextch();
               if ch = #"t" then escape := #"\t"       /* tab */
               else if ch = #"n" then escape := #"\n"  /* newline */
               else if ch = #"v" then escape := #"\v"  /* vertical tab */
               else if ch = #"f" then escape := #"\f"  /* form feed */
               else if ch = #"r" then escape := #"\r"  /* carriage return */
               else if ch = #"\\" or ch = #"\"" or ch = #"\'" then escape := ch
               else if ch = #"^" then
                  begin
                     nextch()
                     if ch >= #"A" and ch <= #"Z" then
                        escape := chr(ord(ch) - 64)
                     else if ch <= #"a" and ch <= #"z" then
                        escape := chr(ord(ch) - 96)
                     else
                        err("illegal escape sequence", src_location())
                  end
               else if is_digit(ch) then
                  begin
                     code := ord(ch) - ord(#"0")
                     nextch()
                     if is_digit(ch) then
                        code := code * 10 + ord(ch) - ord(#"0")
                     else
                        err("illegal escape sequence", src_location())
                     nextch();
                     if is_digit(ch) then
                        code := code * 10 + ord(ch) - ord(#"0")
                     else
                        err("illegal escape sequence", src_location())
                     if code > 255 then
                        err("illegal escape sequence", src_location())
                     escape := chr(code);
                  end
               else if is_space(ch) then
                  begin
                     skip_spaces()
                     if ch = #"\\" then
                        nextch()
                     else
                        err("illegal escape sequence", src_location())
                     esc := false
                  end
               else
                  err("illegal escape sequence", src_location())
               if esc then
                  begin
                     push_buffer(buf, escape)
                     nextch()
                  end
            end
         else
            push_buf()
      recognize(string_token)
      nextch()
   end

scan_char() =
   begin
      nextch()
      if ch = #"\"" then
         scan_string()
      else
         err("illegal character literal", src_location())
      if length(tok.value) <> 1 then
         err("illegal character literal", tok_location())
      recognize(char_token)
   end;

scan_number() =
   begin
      while is_digit(ch) do
         push_buf();
      recognize(number_token)
   end;

scan_id() =
   begin
      while is_alpha(ch) or is_digit(ch) or ch = #"_" do
         push_buf();
      recognize(id_token)
      if string_compare(tok.value, "and") = 0 then tok.tag := and_token
      else if string_compare(tok.value, "array") = 0 then tok.tag := array_token
      else if string_compare(tok.value, "begin") = 0 then tok.tag := begin_token
      else if string_compare(tok.value, "do") = 0 then tok.tag := do_token
      else if string_compare(tok.value, "else") = 0 then tok.tag := else_token
      else if string_compare(tok.value, "end") = 0 then tok.tag := end_token
      else if string_compare(tok.value, "false") = 0 then tok.tag := false_token
      else if string_compare(tok.value, "for") = 0 then tok.tag := for_token
      else if string_compare(tok.value, "if") = 0 then tok.tag := if_token
      else if string_compare(tok.value, "in") = 0 then tok.tag := in_token
      else if string_compare(tok.value, "let") = 0 then tok.tag := let_token
      else if string_compare(tok.value, "mod") = 0 then tok.tag := mod_token
      else if string_compare(tok.value, "nil") = 0 then tok.tag := nil_token
      else if string_compare(tok.value, "of") = 0 then tok.tag := of_token
      else if string_compare(tok.value, "or") = 0 then tok.tag := or_token
      else if string_compare(tok.value, "then") = 0 then tok.tag := then_token
      else if string_compare(tok.value, "true") = 0 then tok.tag := true_token
      else if string_compare(tok.value, "type") = 0 then tok.tag := type_token
      else if string_compare(tok.value, "use") = 0 then tok.tag := use_token
      else if string_compare(tok.value, "while") = 0 then tok.tag := while_token
   end

scan() =
   begin
      skip_spaces()
      clear_buffer(buf)
      tok.value := ""
      tok.file_name := src.file_name
      tok.line := src.line
      tok.col := src.col
      if ch = EOF then recognize(eof_token)
      else if ch = #"," then push_tag(comma_token)
      else if ch = #";" then push_tag(semicolon_token)
      else if ch = #"." then push_tag(dot_token)
      else if ch = #"(" then push_tag(lparen_token)
      else if ch = #")" then push_tag(rparen_token)
      else if ch = #"[" then push_tag(lbracket_token)
      else if ch = #"]" then push_tag(rbracket_token)
      else if ch = #"{" then push_tag(lbrace_token)
      else if ch = #"}" then push_tag(rbrace_token)
      else if ch = #"+" then push_tag(plus_token)
      else if ch = #"-" then push_tag(minus_token)
      else if ch = #"*" then push_tag(mul_token)
      else if ch = #"/" then
         begin
            push_buf();
            if ch = #"*" then scan_comment()
            else recognize(div_token)
         end
      else if ch = #"=" then push_tag(eq_token)
      else if ch = #"<" then
         begin
            push_buf()
            if ch = #">" then push_tag(neq_token)
            else if ch = #"=" then push_tag(leq_token)
            else recognize(lt_token)
         end
      else if ch = #">" then
         begin
            push_buf()
            if ch = #"=" then push_tag(geq_token)
            else recognize(gt_token)
         end
      else if ch = #":" then
         begin
            push_buf()
            if ch = #"=" then push_tag(assign_token)
            else recognize(colon_token)
         end
      else if is_digit(ch) then scan_number()
      else if ch = #"\"" then scan_string()
      else if ch = #"#" then scan_char()
      else if is_alpha(ch) then  scan_id()
      else err("Illegal character", src_location())
   end
